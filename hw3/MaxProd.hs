-- Малашенков Антон, гр. А3401

module MaxProd where

{-
 Написать функцию maxProd :: Real a => [a] -> [a], которая в списке арифметических значений
 находит тройку подряд идущих элементов с максимальным произведением (можно считать,
 что список содержит по крайней мере 3 элемента).
 Например, в списке [1,3,3,6,7,3] такой тройкой будет [3,6,7], (или [6,7,3])
 а в списке [-10,8,4,2,4,4,4] результатом может быть любой из двух списков [8,4,2] или [4,4,4].
-}

maxProd :: (Real a) => [a] -> [a]
maxProd a = maxProd' a

{-
 Функция принимает исходных список и каждый шаг берёт 3 первых элемента.
 Если были взяты последние 3 элемента (остальная часть массива пустая),
 то текущий ответ есть 3 взятых элемента.
 Иначе берём максимум из 3-х взятых элементов и останольй части массив,
 вернув в его начало 2 из 3-ёх взятых элемента.
-}
maxProd' (a:b:c:as)
    | length as == 0 = [a, b, c]
    | otherwise = listMax [a, b, c] (maxProd' (b:c:as))

-- принимает два списка и возвращает тот из них, произведение элементов которого максимально
listMax a b = if multi a > multi b then a else b

-- принимает список и возвращает число - произведение всех элементов данного списка
multi a = foldl (*) 1 a
